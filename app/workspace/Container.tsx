'use client'

import { Button, Modal, TextInput, FileInput, Pagination, FloatingLabel } from "flowbite-react";
import Sidebar from './Sidebar'
import { signOut } from './workspaceActions'
// import React from 'react'
import React, { useCallback, useEffect, useRef, useState } from 'react'

import { useAppSelector, useAppDispatch, useMousePosition } from '../hooks'
import { setSelectedFile, selectWorkspace } from './workspaceSlice'
import { Provider } from 'react-redux'
import { store } from '../store'
import { Document, Page } from 'react-pdf'
import { pdfjs } from 'react-pdf';
import { getModalSetState, setModalSetState } from "./modalSetSlice";
import { getModalFolderState, setModalFolderState } from "./modalFolderSlice"
import { AddFolder, AdjustQuestionPriorityRating, CreateQuestion, CreateSet, DeleteFolder, DeleteQuestionById, DeleteSet, EditQuestion, GetAllQuestionData, GetAutogeneratedQuestionData, GetQuestionData, GetQuestionDataById, ProcessFile } from "../lib/actions";
import { getModalFolderDeletionState, setModalFolderDeletionState } from "./modalFolderDeletionSlice";
import { getModalSetDeletionState, setModalSetDeletionState } from "./modalSetDeletionSlice";

import { PDFDocument } from "pdf-lib"
import { getModalQuestionDeletionState, setModalQuestionDeletionState } from "./modalQuestionDeletionSlice";
const randomColor = require('randomcolor');
import { HexColorPicker } from "react-colorful";

import { motion, useAnimate, useMotionValue } from 'framer-motion';

// pdfjs.GlobalWorkerOptions.workerSrc = new URL(
//     'pdfjs-dist/legacy/build/pdf.worker.min.mjs',
//     import.meta.url,
// ).toString();

const options = {
    cMapUrl: '/cmaps/',
    standardFontDataUrl: '/standard_fonts/',
};

export default function Wrapper({ user }: { user: any }) {
    return (
        <Provider store={store}>
            <Container user={user} />
        </Provider>
    )
}

export function Container({ user }: { user: any }) {

    pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/legacy/build/pdf.worker.min.mjs`;
    // pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

    const files = user[0]?.content;

    // Variables for modals
    const modalSetState = useAppSelector(getModalSetState);
    const [modalSetProcessState, setModalSetProcessState] = useState(false);
    const modalSetDeletionState = useAppSelector(getModalSetDeletionState);
    const modalFolderState = useAppSelector(getModalFolderState);
    const modalFolderDeletionState = useAppSelector(getModalFolderDeletionState);
    const modalQuestionDeletionState = useAppSelector(getModalQuestionDeletionState);
    const selectedFile = useAppSelector(selectWorkspace);
    const dispatch = useAppDispatch()

    // Variables for document display
    const [numPages, setNumPages] = useState<number>(0);
    const [pageNumber, setPageNumber] = useState<number>(1);
    const [currentFiles, setCurrentFiles] = useState(files);

    // Variables for question display
    const [questionBoxRender, setQuestionBoxRender] = useState<any[]>([]);
    const [questionQueueRender, setQuestionQueueRender] = useState<any[]>([]);
    const [selectedQuestion, setSelectedQuestion] = useState<any[]>([]);
    const [renderedSelectQuestion, setRenderedSelectQuestion] = useState<any[]>([]);

    // Variables for manual question addition
    const [isManuallyAddingQuestion, setIsManuallyAddingQuestion] = useState<boolean>(false);
    const isManuallyAddingQuestionRef = useRef(isManuallyAddingQuestion);
    const [isDragging, setIsDragging] = useState(false);
    const leftBound = useMotionValue(0);
    const topBound = useMotionValue(0);
    const leftBoundSave = useRef<number>(0);
    const topBoundSave = useRef<number>(0);
    const rightBound = useRef<number>(0);
    const bottomBound = useRef<number>(0);
    const addingWidth = useMotionValue(0);
    const addingHeight = useMotionValue(0);
    const [addingColor, setAddingColor] = useState("red");
    const [addingScope, addingAnimate] = useAnimate();

    // Variables for question editing
    const [isEditingQuestion, setIsEditingQuestion] = useState<boolean>(false);
    const leftBoundEditing = useMotionValue(0);
    const topBoundEditing = useMotionValue(0);
    const rightBoundEditing = useMotionValue(0);
    const bottomBoundEditing = useMotionValue(0);
    const leftBoundEditingSave = useRef<number>(0);
    const topBoundEditingSave = useRef<number>(0);
    const rightBoundEditingSave = useRef<number>(0);
    const bottomBoundEditingSave = useRef<number>(0);
    const editingWidth = useMotionValue(0);
    const editingHeight = useMotionValue(0);
    const [editingColor, setEditingColor] = useState("red");
    const [editingScope, editingAnimate] = useAnimate();
    const [editingTopLeftScope, editingTopLeftAnimate] = useAnimate();
    const [editingTopRightScope, editingTopRightAnimate] = useAnimate();
    const [editingBottomLeftScope, editingBottomLeftAnimate] = useAnimate();
    const [editingBottomRightScope, editingBottomRightAnimate] = useAnimate();

    // Function runs upon document load to set the number of pages and render the question boxes
    async function onDocumentLoadSuccess({ numPages }: { numPages: number }): Promise<void> {
        setNumPages(numPages);
        const currentQuestions = await GetQuestionData(selectedFile.raw, pageNumber - 1);
        setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));
        const allQuestions = await GetAllQuestionData(selectedFile.raw);
        setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
    }

    useEffect(() => {
        console.log("UPDATE isManuallyAddingQuestionRef EFFECT CALLED")
        if (isManuallyAddingQuestionRef.current !== isManuallyAddingQuestion) {
            isManuallyAddingQuestionRef.current = isManuallyAddingQuestion;
        }
    }, [isManuallyAddingQuestion, isManuallyAddingQuestionRef]);
    const handleQuestionBoxClick = useCallback((question: any, event: React.MouseEvent<HTMLDivElement, MouseEvent>, questions: any[]) => {
        if (!isManuallyAddingQuestionRef.current) {
            setSelectedQuestion((prevSelectedQuestion) => {
                if (event.shiftKey) {
                    const curr = [...prevSelectedQuestion];
                    const minimumPermissibleY = prevSelectedQuestion.reduce((prev, current) => (prev && prev.topBound > current.topBound) ? prev : current);
                    const minimumPermissibleX = prevSelectedQuestion.reduce((prev, current) => (prev && prev.leftBound > current.leftBound) ? prev : current);
                    const idMap = curr.map((question: any) => question.id);
                    console.log("ðŸš€ ~ setSelectedQuestion ~ minimumPermissibleY:", minimumPermissibleY)
                    for (let i = 0; i < questions.length; i++) {
                        const potentialSelect = questions[i];
                        if ((potentialSelect.topBound < question.topBound || potentialSelect.leftBound < question.leftBound)
                            && (potentialSelect.topBound > minimumPermissibleY.topBound)
                            && !idMap.includes(potentialSelect.id)) {
                            curr.push(potentialSelect);
                        }
                    }
                    curr.push(question);
                    return curr;
                } else if (event.ctrlKey) {
                    console.log(prevSelectedQuestion);
                    const curr = [...prevSelectedQuestion, question];
                    console.log("ðŸš€ ~ handleQuestionBoxClick ~ curr:", curr);
                    return curr;
                } else {
                    return [question];
                }
            });
        }
    }, [setSelectedQuestion, isManuallyAddingQuestionRef]);
    // This useEffect is used to render the feedback of any selected question boxes
    useEffect(() => {
        console.log("QUESTION BOX FEEDBACK EFFECT CALLED");

        const curr: any[] = [];
        for (let i = 0; i < selectedQuestion.length; i++) {
            const question = selectedQuestion[i];
            curr.push(
                <div className={"absolute box-border z-30"}
                    style={
                        {
                            backgroundColor: 'green',
                            left: `${question.rightBound}px`,
                            top: `${question.topBound}px`,
                            width: '.25rem',
                            height: `${Math.abs(question.bottomBound - question.topBound)}px`,
                        }
                    }></div>
            )
        }

        setRenderedSelectQuestion(curr);
    }, [selectedQuestion])

    // Event handlers for manual question addition
    const handleDocMouseDown = (event: any) => {
        if (!isManuallyAddingQuestionRef.current) return;
        setIsDragging(true);
        setAddingColor(randomColor());
        const relativeX = event.nativeEvent.offsetX;
        const relativeY = event.nativeEvent.offsetY;
        leftBound.set(relativeX);
        topBound.set(relativeY);
        leftBoundSave.current = relativeX;
        topBoundSave.current = relativeY;
        addingWidth.set(0);
        addingHeight.set(0);
        console.log('Mouse down at:', leftBound, topBound);
    }
    const handleDocMouseMove = (event: any) => {
        if (!isDragging) return;
        const relativeX = event.nativeEvent.offsetX;
        const relativeY = event.nativeEvent.offsetY;

        if (relativeX === rightBound.current && relativeY === bottomBound.current) return;

        rightBound.current = relativeX;
        bottomBound.current = relativeY;

        try {
            addingWidth.set(Math.abs(rightBound.current - leftBoundSave.current));
            addingHeight.set(Math.abs(bottomBound.current - topBoundSave.current));
        } catch (e) {
            console.error(e)
        }

        // Below code is to prevent the box from being drawn in the opposite direction if the user
        // drags the mouse to the 1st, 2nd, or 3rd quadrant
        if (rightBound.current < leftBoundSave.current) {
            leftBound.set(rightBound.current);
        } else if (leftBoundSave.current !== leftBound.get()) {
            leftBound.set(leftBoundSave.current);
        }
        if (bottomBound.current < topBoundSave.current) {
            topBound.set(bottomBound.current);
        } else if (topBoundSave.current !== topBound.get()) {
            topBound.set(topBoundSave.current);
        }

        // Animate the box creation div
        // NOTE: TYPE TWEEN IS NECESSARY TO AVOID LATENCY EFFECT
        addingAnimate(addingScope.current, {
            left: leftBound.get(),
            top: topBound.get(),
            width: addingWidth.get(),
            height: addingHeight.get(),
        },
            { type: 'tween', duration: 0 });

        console.log('Mouse move at:', rightBound.current, bottomBound.current);
    };
    const handleDocMouseUp = () => {
        if (!isDragging) return;
        setIsDragging(false);
        console.log('Mouse up');
    };

    const RenderQuestionBoxes = (questions: any[]) => {
        if (questions.length === 0) return [];
        console.log("ðŸš€ ~ RenderQuestionBoxes ~ questions:", questions)

        let res: any[] = [];
        for (let i = 0; i < questions.length; i++) {
            const question = questions[i];
            const width = Math.abs(question.rightBound - question.leftBound);
            const height = Math.abs(question.bottomBound - question.topBound);
            res.push(
                <div
                    onClick={(event) => {
                        event.preventDefault();
                        handleQuestionBoxClick(question, event, questions);
                    }}
                    className={"absolute box-border opacity-20 z-30"}
                    style={
                        {
                            backgroundColor: question.color,
                            left: `${question.leftBound}px`,
                            top: `${question.topBound}px`,
                            width: `${width}px`,
                            height: `${height}px`,
                        }
                    }
                    key={question.id}>
                </div>
            )
        }
        console.log("ðŸš€ ~ RenderQuestionBoxes ~ res:", res)
        return res;
    }

    const RenderQuestionQueue = (questions: any[]) => {
        let res: any[] = [];
        const maxRenderCount = 10;
        const hasAnsweredQuestions = questions.filter((question) => question.hasAnswer === true);
        const sortedQuestionsByPriority = hasAnsweredQuestions.sort((a, b) => a.priorityRating - b.priorityRating);
        console.log("ðŸš€ ~ RenderQuestionQueue ~ sortedQuestionsByPriority:", sortedQuestionsByPriority)
        for (let i = 0; i < Math.min(maxRenderCount, sortedQuestionsByPriority.length); i++) {
            const question = sortedQuestionsByPriority[i];
            res.push(
                <Button onClick={async () => {
                    setSelectedQuestion([question]);
                    setPageNumber(question.pageNumber + 1);
                    const currentQuestions = await GetQuestionData(selectedFile.raw, question.pageNumber);
                    setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));
                }}>{question.name}</Button>
            )
        }
        return res;
    }

    return (
        <div className="bg-white min-h-screen">
            <div className="flex flex-row">
                {/* SIDEBAR */}
                <div className="basis-1/4 flex flex-col">

                    {/* Sidebar with files */}
                    <Sidebar files={currentFiles} userId={user[0].id} />

                    {/* Sign out button */}
                    <form
                        action={signOut}
                    >
                        <Button type="submit">
                            <div className="hidden md:block">Sign Out</div>
                        </Button>
                    </form>

                    {/* Detect and autogenerate questions button */}
                    <form action={async () => {
                        const isAutogeneratedPresent = (await GetAutogeneratedQuestionData(selectedFile.raw)).length > 0;
                        if (!isAutogeneratedPresent) {
                            ProcessFile(selectedFile.raw, numPages as number);
                        } else {
                            setModalSetProcessState(true);
                        }
                    }}>
                        <Button type="submit">
                            Automatically detect questions
                        </Button>
                    </form>

                    {/* Blank space question deselection */}
                    <div onClick={() => {
                        setSelectedQuestion([]);
                    }} className="bg-white flex-grow"></div>

                </div>
                {/* DOCUMENT DISPLAY */}
                <div className="flex flex-col basis-1/2 justify-items-center">
                    {/* Question queue */}
                    <div className="justify-self-center">
                        <Button.Group>
                            {...questionQueueRender}
                        </Button.Group>
                    </div>

                    {/* Document render */}
                    <div className="flex-grow flow-col flex relative justify-center items-center z-40">
                        {isManuallyAddingQuestion ?
                            <div>
                                <motion.div className="absolute box-border z-30"
                                    ref={addingScope}
                                    initial={{ left: leftBound.get(), top: topBound.get(), width: 0, height: 0 }}
                                    style={
                                        {
                                            backgroundColor: addingColor,
                                            opacity: 0.75,
                                            pointerEvents: "none"
                                        }
                                    }>
                                </motion.div>
                            </div>
                            : <div></div>}
                        {isEditingQuestion &&
                            <div>
                                {/* Top left dragging point */}
                                <motion.div className="absolute box-border outline outline-slate-900 border z-40"
                                    initial={{ left: leftBoundEditing.get() - 5, top: topBoundEditing.get() - 5, width: 10, height: 10 }}
                                    ref={editingTopLeftScope}
                                    onMouseUp={() => {
                                        leftBoundEditingSave.current = leftBoundEditing.get();
                                        topBoundEditingSave.current = topBoundEditing.get();
                                        editingTopLeftAnimate(editingTopLeftScope.current,
                                            { left: leftBoundEditing.get() - 5, top: topBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    drag
                                    dragElastic={0}
                                    dragMomentum={false}
                                    dragSnapToOrigin={true}
                                    dragConstraints={{ bottom: bottomBoundEditing.get() - topBoundEditing.get(), right: rightBoundEditing.get() - leftBoundEditing.get() }}
                                    onDrag={(event, info) => {
                                        console.log("TOP LEFT:", info.offset.x, info.offset.y);
                                        const newLeftBound = leftBoundEditingSave.current + info.offset.x;
                                        const newTopBound = topBoundEditingSave.current + info.offset.y;
                                        if (newLeftBound < rightBoundEditing.get()) leftBoundEditing.set(newLeftBound);
                                        if (newTopBound < bottomBoundEditing.get()) topBoundEditing.set(newTopBound);
                                        editingWidth.set(Math.abs(rightBoundEditing.get() - leftBoundEditing.get()));
                                        editingHeight.set(Math.abs(bottomBoundEditing.get() - topBoundEditing.get()));
                                        editingAnimate(editingScope.current,
                                            { left: leftBoundEditing.get(), top: topBoundEditing.get(), width: editingWidth.get(), height: editingHeight.get() },
                                            { type: 'tween', duration: 0 });
                                        editingTopRightAnimate(editingTopRightScope.current,
                                            { top: topBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                        editingBottomLeftAnimate(editingBottomLeftScope.current,
                                            { left: leftBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    style={{ backgroundColor: 'white' }}></motion.div>

                                {/* Top right dragging point */}
                                <motion.div className="absolute box-border outline outline-slate-900 border z-40"
                                    initial={{ left: rightBoundEditing.get() - 5, top: topBoundEditing.get() - 5, width: 10, height: 10 }}
                                    ref={editingTopRightScope}
                                    onMouseUp={() => {
                                        rightBoundEditingSave.current = rightBoundEditing.get();
                                        topBoundEditingSave.current = topBoundEditing.get();
                                        editingTopRightAnimate(editingTopRightScope.current,
                                            { left: rightBoundEditing.get() - 5, top: topBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    drag
                                    dragElastic={0}
                                    dragMomentum={false}
                                    dragSnapToOrigin={true}
                                    dragConstraints={{ bottom: bottomBoundEditing.get() - topBoundEditing.get(), left: leftBoundEditing.get() - rightBoundEditing.get() }}
                                    onDrag={(event, info) => {
                                        console.log("TOP RIGHT:", info.offset.x, info.offset.y);
                                        const newRightBound = rightBoundEditingSave.current + info.offset.x;
                                        const newTopBound = topBoundEditingSave.current + info.offset.y;
                                        if (newRightBound > leftBoundEditing.get()) rightBoundEditing.set(newRightBound);
                                        if (newTopBound < bottomBoundEditing.get()) topBoundEditing.set(newTopBound);
                                        editingWidth.set(Math.abs(rightBoundEditing.get() - leftBoundEditing.get()));
                                        editingHeight.set(Math.abs(bottomBoundEditing.get() - topBoundEditing.get()));
                                        editingAnimate(editingScope.current,
                                            { left: leftBoundEditing.get(), top: topBoundEditing.get(), width: editingWidth.get(), height: editingHeight.get() },
                                            { type: 'tween', duration: 0 });
                                        editingTopLeftAnimate(editingTopLeftScope.current,
                                            { top: topBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                        editingBottomRightAnimate(editingBottomRightScope.current,
                                            { left: rightBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    style={{ backgroundColor: 'white' }}></motion.div>

                                {/* Bottom left dragging point */}
                                <motion.div className="absolute box-border outline outline-slate-900 border z-40"
                                    initial={{ left: leftBoundEditing.get() - 5, top: bottomBoundEditing.get() - 5, width: 10, height: 10 }}
                                    ref={editingBottomLeftScope}
                                    onMouseUp={() => {
                                        leftBoundEditingSave.current = leftBoundEditing.get();
                                        bottomBoundEditingSave.current = bottomBoundEditing.get();
                                        editingBottomLeftAnimate(editingBottomLeftScope.current,
                                            { left: leftBoundEditing.get() - 5, top: bottomBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    drag
                                    dragElastic={0}
                                    dragMomentum={false}
                                    dragSnapToOrigin={true}
                                    dragConstraints={{ top: topBoundEditing.get() - bottomBoundEditing.get(), right: rightBoundEditing.get() - leftBoundEditing.get() }}
                                    onDrag={(event, info) => {
                                        console.log("BOTTOM LEFT:", info.offset.x, info.offset.y);
                                        const newLeftBound = leftBoundEditingSave.current + info.offset.x;
                                        const newBottomBound = bottomBoundEditingSave.current + info.offset.y;
                                        if (newLeftBound < rightBoundEditing.get()) leftBoundEditing.set(newLeftBound);
                                        if (newBottomBound > topBoundEditing.get()) bottomBoundEditing.set(newBottomBound);
                                        editingWidth.set(Math.abs(rightBoundEditing.get() - leftBoundEditing.get()));
                                        editingHeight.set(Math.abs(bottomBoundEditing.get() - topBoundEditing.get()));
                                        editingAnimate(editingScope.current,
                                            { left: leftBoundEditing.get(), top: topBoundEditing.get(), width: editingWidth.get(), height: editingHeight.get() },
                                            { type: 'tween', duration: 0 });
                                        editingTopLeftAnimate(editingTopLeftScope.current,
                                            { left: leftBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                        editingBottomRightAnimate(editingBottomRightScope.current,
                                            { top: bottomBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    style={{ backgroundColor: 'white' }}></motion.div>

                                {/* Bottom right dragging point */}
                                <motion.div className="absolute box-border outline outline-slate-900 border z-40"
                                    initial={{ left: rightBoundEditing.get() - 5, top: bottomBoundEditing.get() - 5, width: 10, height: 10 }}
                                    ref={editingBottomRightScope}
                                    onMouseUp={() => {
                                        rightBoundEditingSave.current = rightBoundEditing.get();
                                        bottomBoundEditingSave.current = bottomBoundEditing.get();
                                        editingBottomRightAnimate(editingBottomRightScope.current,
                                            { left: rightBoundEditing.get() - 5, top: bottomBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    drag
                                    dragElastic={0}
                                    dragMomentum={false}
                                    dragSnapToOrigin={true}
                                    dragConstraints={{ top: topBoundEditing.get() - bottomBoundEditing.get(), left: leftBoundEditing.get() - rightBoundEditing.get() }}
                                    onDrag={(event, info) => {
                                        console.log("BOTTOM RIGHT:", info.offset.x, info.offset.y);
                                        const newRightBound = rightBoundEditingSave.current + info.offset.x;
                                        const newBottomBound = bottomBoundEditingSave.current + info.offset.y;
                                        if (newRightBound > leftBoundEditing.get()) rightBoundEditing.set(newRightBound);
                                        if (newBottomBound > topBoundEditing.get()) bottomBoundEditing.set(newBottomBound);
                                        editingWidth.set(Math.abs(rightBoundEditing.get() - leftBoundEditing.get()));
                                        editingHeight.set(Math.abs(bottomBoundEditing.get() - topBoundEditing.get()));
                                        editingAnimate(editingScope.current,
                                            { left: leftBoundEditing.get(), top: topBoundEditing.get(), width: editingWidth.get(), height: editingHeight.get() },
                                            { type: 'tween', duration: 0 });
                                        editingTopRightAnimate(editingTopRightScope.current,
                                            { left: rightBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                        editingBottomLeftAnimate(editingBottomLeftScope.current,
                                            { top: bottomBoundEditing.get() - 5 },
                                            { type: 'tween', duration: 0 });
                                    }}
                                    style={{ backgroundColor: 'white' }}></motion.div>

                                {/* Feedback/final question box */}
                                <motion.div className="absolute box-border z-30"
                                    ref={editingScope}
                                    initial={{ left: leftBoundEditing.get(), top: topBoundEditing.get(), width: editingWidth.get(), height: editingHeight.get() }}
                                    style={
                                        {
                                            backgroundColor: editingColor,
                                            opacity: 0.75,
                                            pointerEvents: "none"
                                        }
                                    }>
                                </motion.div>
                            </div>}
                        {questionBoxRender}
                        {renderedSelectQuestion}
                        <Document
                            onMouseDown={handleDocMouseDown}
                            onMouseMove={handleDocMouseMove}
                            onMouseUp={handleDocMouseUp}
                            file={selectedFile.entities[selectedFile.entities.length - 1]}
                            onLoadSuccess={onDocumentLoadSuccess} className="w-full">
                            <Page pageNumber={pageNumber} width={816} renderAnnotationLayer={false} renderTextLayer={false} />
                        </Document>
                    </div>
                </div>

                {/* CONTROL PANEL */}
                <div className="basis-1/4">
                    <div className="sticky top-0">
                        {/* PAGINATION */}
                        {numPages > 0
                            ? <Pagination currentPage={pageNumber} totalPages={numPages!}
                                onPageChange={
                                    async (page: number) => {
                                        setPageNumber(page);
                                        console.log("ðŸš€ ~ page:", page)
                                        const currentQuestions = await GetQuestionData(selectedFile.raw, page - 1);
                                        // console.log("ðŸš€ ~ currentQuestions:", await currentQuestions)
                                        setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));
                                    }
                                } />
                            : <div></div>}


                        {/* QUESTION CONTROL */}
                        <div className="mt-4 h-full">
                            {!isManuallyAddingQuestion && !isEditingQuestion ?
                                <div>
                                    {(selectedQuestion.length === 0)
                                        ? <p className="text-slate-900">Select a question to get started</p>
                                        :
                                        <div className="flex flex-col flex-wrap h-full">
                                            {selectedQuestion.length > 1 ? <div></div>
                                                : <div>
                                                    <h1 className="text-slate-900">{`Question ${selectedQuestion[0].name}`}</h1>
                                                    <Button.Group>
                                                        <Button onClick={async () => {
                                                            await AdjustQuestionPriorityRating(selectedQuestion[0], -2);
                                                            setSelectedQuestion([]);
                                                            const allQuestions = await GetAllQuestionData(selectedFile.raw);
                                                            setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
                                                        }}>Clueless</Button>
                                                        <Button onClick={async () => {
                                                            await AdjustQuestionPriorityRating(selectedQuestion[0], -1);
                                                            setSelectedQuestion([]);
                                                            const allQuestions = await GetAllQuestionData(selectedFile.raw);
                                                            setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
                                                        }}>Trivial Error</Button>
                                                        <Button onClick={async () => {
                                                            await AdjustQuestionPriorityRating(selectedQuestion[0], 1);
                                                            setSelectedQuestion([]);
                                                            const allQuestions = await GetAllQuestionData(selectedFile.raw);
                                                            setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
                                                        }}>Manageable</Button>
                                                        <Button onClick={async () => {
                                                            await AdjustQuestionPriorityRating(selectedQuestion[0], 2);
                                                            setSelectedQuestion([]);
                                                            const allQuestions = await GetAllQuestionData(selectedFile.raw);
                                                            setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
                                                        }}>Easy</Button>
                                                    </Button.Group>
                                                </div>}


                                            <div className="bottom-1 mt-32">
                                                <Button color="warning"
                                                    onClick={() => {
                                                        dispatch(setModalQuestionDeletionState(selectedQuestion.map((question: any) => question.id)));
                                                    }}>Delete question{selectedQuestion.length > 1 ? 's' : ''}</Button>
                                            </div>
                                        </div>}
                                </div>
                                : <div></div>}

                            {/* MANUALLY ADD QUESTION */}
                            {isManuallyAddingQuestion
                                ?
                                <div>
                                    <form onSubmit={async (event) => {
                                        event.preventDefault();
                                        const formData = new FormData(event.target as HTMLFormElement);

                                        const inputData = {
                                            fileId: selectedFile.raw,
                                            name: formData.get("file-name") as string,
                                            isAutogenerated: false,
                                            pageNumber: pageNumber - 1,
                                            leftBound: Math.min(leftBound.get(), leftBoundSave.current),
                                            topBound: Math.min(topBound.get(), topBoundSave.current),
                                            rightBound: Math.max(rightBound.current, leftBoundSave.current),
                                            bottomBound: Math.max(bottomBound.current, topBoundSave.current),
                                            priorityRating: 0,
                                            color: addingColor,
                                        }

                                        await CreateQuestion(inputData);

                                        const currentQuestions = await GetQuestionData(selectedFile.raw, pageNumber - 1);
                                        setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));

                                        setIsDragging(false);
                                        setIsManuallyAddingQuestion(false);
                                    }}>
                                        <FloatingLabel variant="outlined" label="File Name/Index" name="file-name" />
                                        <HexColorPicker color={addingColor} onChange={setAddingColor} />;
                                        <Button type="submit">Save</Button>
                                    </form>
                                    <Button onClick={() => setIsManuallyAddingQuestion(false)}>Cancel</Button>
                                </div>
                                : <Button onClick={() => setIsManuallyAddingQuestion(true)}>Manually add question</Button>}

                            {/* EDIT QUESTION */}
                            {isEditingQuestion
                                ?
                                <div>
                                    <form onSubmit={async (event) => {
                                        event.preventDefault();
                                        const formData = new FormData(event.target as HTMLFormElement);

                                        const inputData = {
                                            name: formData.get("file-name") as string,
                                            leftBound: leftBoundEditing.get(),
                                            topBound: topBoundEditing.get(),
                                            rightBound: rightBoundEditing.get(),
                                            bottomBound: bottomBoundEditing.get(),
                                            color: editingColor,
                                        }

                                        await EditQuestion(selectedQuestion[0].id, inputData);

                                        const currentQuestions = await GetQuestionData(selectedFile.raw, pageNumber - 1);
                                        setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));

                                        setIsEditingQuestion(false);
                                    }}>
                                        <FloatingLabel variant="outlined" label="File Name/Index" name="file-name" />
                                        <HexColorPicker color={editingColor} onChange={setEditingColor} />;
                                        <Button type="submit">Save</Button>
                                    </form>
                                    <Button onClick={() => setIsEditingQuestion(false)}>Cancel</Button>
                                </div>
                                : <Button onClick={() => {
                                    if (selectedQuestion.length === 0) return;
                                    setIsEditingQuestion(true);
                                    setEditingColor(selectedQuestion[0].color);
                                    leftBoundEditing.set(selectedQuestion[0].leftBound);
                                    topBoundEditing.set(selectedQuestion[0].topBound);
                                    rightBoundEditing.set(selectedQuestion[0].rightBound);
                                    bottomBoundEditing.set(selectedQuestion[0].bottomBound);
                                    leftBoundEditingSave.current = selectedQuestion[0].leftBound;
                                    topBoundEditingSave.current = selectedQuestion[0].topBound;
                                    rightBoundEditingSave.current = selectedQuestion[0].rightBound;
                                    bottomBoundEditingSave.current = selectedQuestion[0].bottomBound;
                                    editingWidth.set(Math.abs(rightBoundEditing.get() - leftBoundEditing.get()));
                                    editingHeight.set(Math.abs(bottomBoundEditing.get() - topBoundEditing.get()));
                                }}>Edit Question</Button>}
                        </div>
                    </div>
                </div>
            </div>

            <div> {/* MODALS */}
                {/* MODAL FOR CREATING A SET */}
                <Modal show={modalSetState.open} onClose={() => dispatch(setModalSetState(''))}>
                    <Modal.Header></Modal.Header>
                    <Modal.Body>
                        <form onSubmit={async (event) => {
                            event.preventDefault();
                            const formData = new FormData(event.target as HTMLFormElement);
                            const file = formData.get("file") as File;
                            const setName = formData.get("set-name") as string;
                            const buffer = await file.arrayBuffer();
                            const uintarr = new Uint8Array(await buffer);

                            const pdfDoc = await PDFDocument.load(await uintarr);
                            const numberOfPages = pdfDoc.getPageCount();

                            const parentFolder = modalSetState.folder;

                            const updatedFiles = await CreateSet(user[0], setName, parentFolder, uintarr, numberOfPages);
                            setCurrentFiles(await updatedFiles);
                            dispatch(setModalSetState(''));
                        }}>
                            <TextInput type="text" name="set-name" />
                            <FileInput name="file" />
                            <Button type="submit">Create Set</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>

                {/* MODAL FOR PROCESSING A SET {IF PREVIOUS AUTOGENERATIONS HAVE OCCURED} */}
                <Modal show={modalSetProcessState} onClose={() => setModalSetProcessState(false)}>
                    <Modal.Header>Attention: Proceeding will result in the deletion of your old <b>autogenerated</b> questions</Modal.Header>
                    <Modal.Body>
                        <form onSubmit={async (event) => {
                            event.preventDefault();
                            await ProcessFile(selectedFile.raw, numPages as number);
                            setModalSetProcessState(false)
                        }}>
                            <Button type="submit">Replace old autogenerated questions with new generations</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>

                {/* MODAL FOR DELETING A SET */}
                <Modal show={modalSetDeletionState.open} onClose={() => dispatch(setModalSetDeletionState(''))}>
                    <Modal.Header>Attention: Proceed with deleting this set?</Modal.Header>
                    <Modal.Body>
                        <form onSubmit={async (event) => {
                            event.preventDefault();
                            const targetSetID = modalSetDeletionState.set;
                            console.log("ðŸš€ ~ <formonSubmit={ ~ targetSetID:", targetSetID)
                            const updatedFiles = DeleteSet(user[0], currentFiles, targetSetID);
                            setCurrentFiles(await updatedFiles);
                            dispatch(setModalSetDeletionState(''))
                        }}>
                            <Button type="submit">Delete set</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>

                {/* MODAL FOR CREATING A FOLDER */}
                <Modal show={modalFolderState.open} onClose={() => dispatch(setModalFolderState(''))}>
                    <Modal.Header></Modal.Header>
                    <Modal.Body>
                        <form action={async (formData) => {
                            const parentFolder = modalFolderState.folder;
                            const prospectiveFolder = formData.get("folder-name");
                            const updatedFiles = await AddFolder(parentFolder, prospectiveFolder as string, currentFiles, user[0]);
                            setCurrentFiles(await updatedFiles)
                            dispatch(setModalFolderState(''))
                        }}>
                            <TextInput type="text" name="folder-name" />
                            <Button type="submit">Add {(modalFolderState.folder) ? 'Subfolder' : 'Folder'}</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>


                {/* MODAL FOR DELETING A FOLDER */}
                <Modal show={modalFolderDeletionState.open} onClose={() => dispatch(setModalFolderDeletionState(''))}>
                    <Modal.Header>Attention: Proceed with deleting this folder and its contents?</Modal.Header>
                    <Modal.Body>
                        <form action={async () => {
                            const targetFolder = modalFolderDeletionState.folder;
                            console.log("ðŸš€ ~ <formaction={ ~ targetFolder:", targetFolder)
                            const updatedFiles = await DeleteFolder(targetFolder, currentFiles, user[0]);
                            setCurrentFiles(await updatedFiles);
                            dispatch(setModalFolderDeletionState(''))
                        }}>
                            <Button type="submit">Delete folder</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>

                {/* MODAL FOR DELETING A QUESTION */}
                <Modal show={modalQuestionDeletionState.open} onClose={() => dispatch(setModalQuestionDeletionState([]))}>
                    <Modal.Header>Attention: Proceed with deleting {selectedQuestion.length > 1 ? 'these questions' : 'this question'}?</Modal.Header>
                    <Modal.Body>
                        <form action={async () => {
                            const targetQuestions = modalQuestionDeletionState.questions; // ARRAY OF QUESTION ID
                            // ITERATE THROUGH ARRAY AND DELETE EACH QUESTION BY ID ON BACKEND
                            for (const targetQuestion of targetQuestions) {
                                await DeleteQuestionById(targetQuestion);
                            }
                            // REFRESH QUESTION BOXES AND QUEUE
                            const currentQuestions = await GetQuestionData(selectedFile.raw, pageNumber - 1);
                            setQuestionBoxRender(RenderQuestionBoxes(await currentQuestions));
                            const allQuestions = await GetAllQuestionData(selectedFile.raw);
                            setQuestionQueueRender(RenderQuestionQueue(await allQuestions));
                            // RESET MODAL STATE
                            dispatch(setModalQuestionDeletionState([]))
                        }}>
                            <Button type="submit">Delete question{selectedQuestion.length > 1 ? 's' : ''}</Button>
                        </form>
                    </Modal.Body>
                    <Modal.Footer>
                    </Modal.Footer>
                </Modal>
            </div>

        </div>
    )
}
